# Title

## Built-in Type Methods

The built-in types and subtypes have behaviors exposed as properties and methods that are quite powerful and useful

Briefly, there is a _String_ object wrapper form typically called a _native_ that pairs with the primitive _string type_, this object wrapper is the one that defines the methods and properties

Ejemplo:

  ```js
  var a = "hello world";
  var b = 3.14159;
  a.length; // 11
  a.toUpperCase(); // "HELLO WORLD"
  b.toFixed(4); // "3.1416"
  ```

  When you use a primitive value like "hello world" as an object by referencing a property or method (e.g., a.toUpperCase() in the previous snippet)

  JS automatically “boxes” the value to its object wrapper counterpart (hidden under the covers)

A _string_ value can be wrapped by a _String object_

A _number_ can be wrapped by a _Number object_

A _boolean_ can be wrapped by a _Boolean object_

## Comparing Values

There are two main types of value comparison that you will need to make in your JS programs

1. equality
2. inequality

The result of any comparison is a strictly boolean value

### Coercion

Comes in two forms in JavaScript: _explicit_ and _implicit_

```js
// Explicit
var a = "42"
var b = Number(a)

a; // "42"
b; // 42
```

```js
var a = '42'
var b = a * 1 // "42" implicitly coerced to 42

a; // "42"
b; // 42
```

### Truthy & falsy

1. _Falsy_
    1. "" (empty string)
    2. 0, -0, NaN (invalid number)
    3. null, undefined
    4. false

2. _Truthy_
    Any value thats not falsy, is truthy

A non-boolean value only follow truthy/false coercion if it's actually coerced to a _boolean_

### Equality

The difference between `==` and `===` is that `==` allows coercion when checking for value equality

```js
var a = "42";
var b = 42;
a == b; // true
a === b; // false
```

## Function Scopes

You use the _var_ keyword to declare a variable that will belong to the current function scope, or the global scope if at the top level outside of any function

_Hoisting_ wherever a _var_ appears inside a scope, that declaration is taken to belong to the entire scope and accesible everywhere throughout

Metaphorically, this behavior is called _hoisting_, when a _var_ declaration is conceptually "moved" to the top of its enclosing scope

```js
var a = 2

foo(); // works because foo() declaration is "hoisted"

function foo() {
  a = 3;
  console.log(a) // 3
  var a;
}
console.log(a) // 2
```

### Nested scopes

When you declare a variable it is available anywhere in that scope as well as any lower/inner scopes

```js
function foo() {
  var a = 1

  function bar() {
    var b = 2

    function baz(){
      var c = 3

      console.log( a, b, c) // 1,2,3
    }

    baz();
    console.log( a,b ) // 1, 2
  }

  bar()
  console.log(a) //1
}

foo();
```

1. c no esta disponible en _bar()_ porque esta declarada en _baz()_
2. b no esta disponible en _foo()_

Con ES6 ya podemos definir variables con _let_ dentro de llaves {}, lo que genera que su scope no salga de ahi permitiendo mejor mantenibilidad

## Functions as Values

```js
function foo() {

}
```

En el código anterior, _foo_ es básicamente una variable in the outer enclosing scope thats given a reference to the _function_. That is, the function itself is a value

No solo se le puede pasar un argumento a una función, sino una función misma puede ser un valor que es asignado a una variable, pasada o retornada de otra función

```js
var foo = function() {

};

var x = function bar() {

};
```

1. The first function expression assigned to the _foo_ variable is called anonymous

2. The second function expression is named (bar)

## Immediately Invoked Function Expressions (IIFEs)

We could execute a function expression if we used `foo()` or `x()`

There's another way to execute a function expression, referred as immediately invoked function expression

```js
(function IIFE(){
  console.log('Hello')
})()
```

1. The outer (...) that surrounds the (`function IIFE(){..}`) function expression is just a nuance of JS grammar needed to prevent it from being treated as a normal function declaration

2. The final () at the end of the expression is what actually executes the function expression referenced immediately before

That may seem strange, but it's not as foreign as first glance, consider the similarities between foo and IIFE

```js
function foo() {...}

// foo function reference expression,
// then `()` executes it
foo();

// `IIFE` function expression,
// then `()` executes it
(function IIFE(){ .. })();
```

- Listing the (function IIFE(){ .. }) before its executing () is the same as including foo before its executing()
- In both cases, the function reference is executed with () immediately after it

IIFE is just a function, and functions create variable scope, using an IIFE is often used to declare variable that wont affect the surrounding code ouside the IIFE

```js
var a = 42;
(function IIFE(){
  var a = 10;
  console.log( a ); //10
})();
console.log( a ) // 42
```

## Closure

You can think of closure as a way to remember and continue to access a functions scope (its variables) even once the function has finished running

```js
function makeAdder(x) {
  // parameter 'x' is an inner variable

  // inner function add() uses 'x' so
  // it has a 'closure' over it
  function add(y) {
    return y + x;
  };

  return add;
}
```

1. The reference to the inner _add()_ function that gets returned with each call to the outer _makeAdder()_ is able to remember whatever x value was passed in to _makeAdder()_

Lets use _makeAdder()_

```js
// `plusOne` gets a reference to the inner `add(..)`
// function with closure over the `x` parameter of
// the outer `makeAdder(..)`
var plusOne = makeAdder( 1 );

// `plusTen` gets a reference to the inner `add(..)`
// function with closure over the `x` parameter of
// the outer `makeAdder(..)`

49var plusTen = makeAdder( 10 );
plusOne( 3 );
plusOne( 41 ); // 4 <-- 1 + 3
plusTen( 13 ); // 42 <-- 1 + 41
```

1. When we call _makeAdder(1)_ we get back a reference to its inner _add()_ that remembers x as 1. We call this function reference _plusOne()_

2. When we call _plusOne(3)_, it adds 3 (its inner y) to the 1 (remembered by x) and we get 4 as the result

### Modules

The most common usage of closure in JavaScript is the module pattern.

Modules let you define private implementation details (variables, functions) that are hidden from the outside world, as well as a public API that is accessible from the outside

```js
function User() {
  var username, password;

  function doLogin(user,pw) {
    username = user
    password = pw
  }

  var publicAPI = {
    login: doLogin
  }

  return publicAPI
}

// Create a User module instance
var fred = User();

fred.login("fred", "123")
```

1. The _User()_ function serves as an outer scope that
    1. Holds the variables `username`, `password` and the inner `doLogin()` function
        - These are all _PRIVATE_ inner details of this _User module_ that cannot be accessed from the outside world

2. Executing _User()_ creates an instance of the User module
    - A whole new scope is created, a new copy of each of these inner variables/functions
    - We assign this instance to _fred_
    - If we run _User()_ again, we did get a new instance entirely separate from _fred_

3. The inner _doLogin()_ function has a closure over username and password, meaning it will retain its access to them even after the _User()_ function finishes running

4. _publicAPI_ is an object with one property/method on it, _login_ which is a reference to the inner _doLogin()_ function.
    - When we return _publicAPI_ from User(), it becomes the instance we call _fred_

5. At this point, the outer _User()_ function has finished executing
    - Normally, you did think the inner variables like _username_ and _password_ have gone away
    - They have not, because there's a closure in the _login()_ function keeping them alive

6. That's why we can call _fred.login()_
    - That's the same as calling the inner _doLogin()_
    - _fred.login()_ can still access username and password

## this Identifier

If a function has a _this_ reference inside it, that reference usually points to an object

But which _object it point to_ depends on how the function was called

_this_ does not refer to the function itself

```js
function foo() {
  console.log( this.bar )
}

var bar = "global"

var obj1 = {
  bar: "obj1",
  foo: foo,
}

var obj2 = {
  bar: "obj2"
}

foo(); // global
obj1.foo(); // "obj1"
foo.call(obj2); // "obj2"
new foo(); // undefined
```

There are four rules for how _this_ gets set ann are shown in the last 4 lines of code

1. _foo()_ sets _this_ to the global object in non-strict mode
    - In strict mode, _this_ would be undefined and you would get an error

2. _obj1.foo()_ sets _this_ to the obj1 object

3. _foo.call(obj2)_ sets _this_ to the obj2 object
    - _Function.prototype.call()_ calls a function with a given _this_ value and arguments provided individually

4. _new foo()_ sets _this_ to a brand new empty object

To understand what _this_ points to, you have to examine how the function in question was called
