# React: Software Architecture

Es el estudio de estructura, organizacion y patrones del desarrollo de un proyecto, primeramente los que impactan la productividad de desarrollo en el tiempo

![1](images/11_1.png)

Software architecture es pensado para ser independiente de la tecnologia que estemos usando, miraremos ejemplos con React

Hay 5 temas principales:

1. Server-side rendering
2. State management: Como manejar apropiadamente la data
3. Data loading: Cual es la relacion apropiada entre front y back y como se comunican mas eficientemente, especialmente en el contexto de server-side rendering
4. Code splitting: Como entregamos eficientemente el codigo al cliente
5. Project organization: Como organizar el codigo de tal manera que sea facil para otros programadores

## Server-Side Rendering

En el flujo normal de una aplicacion de React, el cliente hace una peticion al servidor y carga el `index.html` el cual no contiene nada, ese index le dice al explorador que cargue los scripts de React, que son los que en realidad renderizan todos los elementos HTML en la pagina

Server-Side Rendering es cuando el servidor es el encargado de correr los scripts de React y renderizar los elementos

![2](images/11_2.png)

### Basic React SSR

Teniendo una aplicacion basica de react empezaremos a prepararla para que haga server side rendering

`npm install --save-dev @babel/core @babel/node @babel/preset-env @babel/preset-react nodemon`

`npm install express`

```js
//server.js
import express from 'express';
import React from 'react';
import { renderToString } from 'react-dom/server';

const app = express();

// Todas las rutas devolvera el HTML
app.get('/*', (req, res) => {
  // render es una funcion a la que le podemos pasar jsx y lo renderizara como html
  const reactApp = renderToString(<h1>Hello from the server side</h1>);

  return res.send(`
    <html>
      <body>
        <div id="root">${reactApp}</div>
      </body>
    </html>
    `);
});

app.listen(8080, () => {
  console.log('Server listening on port 8080');
});
```

```json
// .babelrc
{
  "presets": ["@babel/preset-env", "@babel/preset-react"]
}
```

Corremos la aplicacion con `npx babel-node server.js`

### Building and rendering an SSR React App

Por ahora estamos renderizando un HTML basico desde JSX en vez de renderizar nuestra React app, queremos renderizar la app y los componentes de las paginas que tenemos para eso debemos:

1. Build our react app: `npm run build`

   - Esto generara un directorio build que contiene todo el codigo minificado y transpilado

2. Desirle al servidor que sirva estaticamente los archivos dentro de la carpeta build y renderizar el componente Home. Para correr `npx nodemon --exec npx babel-node server.js`

```js
// server.js
import express from 'express';
import React from 'react';
import { renderToString } from 'react-dom/server';
import { Home } from './src/pages/Home';

const app = express();

// Por defecto si express esta sirviendo una carpeta estatica y ve que hay un index, y que el usuario esta intentando cargar data de el, inmediatamente envia el index
app.use(express.static('./build', { index: false }));

// Todas las rutas devolvera el HTML
app.get('/*', (req, res) => {
  // render es una funcion a la que le podemos pasar jsx y lo renderizara como html
  const reactApp = renderToString(<Home />);

  return res.send(`
          <html>
            <body>
              <div id="root">${reactApp}</div>
            </body>
          </html>
          `);
});

app.listen(8080, () => {
  console.log('Server listening on port 8080');
});
```

### Routing with server side rendering

Acabamos de renderizar 1 solo componente, pero lo ideal seria renderizar toda la APP, es decir, el app.js y esto no lo habiamos hecho porque tenemos que realizar el routing

1. Importaremos StaticRouter, basicamente es el equivalente a BrowserRouter que usamos en el frontend

   - Se le pasa un prop llamado location, que le permite saber que ruta esta solicitando el usuario

```js
// server.js
import express from 'express';
import React from 'react';
import { renderToString } from 'react-dom/server';
import { StaticRouter } from 'react-router-dom';
import App from './src/App';

const app = express();

// Por defecto si express esta sirviendo una carpeta estatica y ve que hay un index, y que el usuario esta intentando cargar data de el, inmediatamente envia el index
app.use(express.static('./build', { index: false }));

// Todas las rutas devolvera el HTML
app.get('/*', (req, res) => {
  // render es una funcion a la que le podemos pasar jsx y lo renderizara como html
  const reactApp = renderToString(
    <StaticRouter location={req.url}>
      <App />
    </StaticRouter>
  );

  return res.send(`
    <html>
      <body>
        <div id="root">${reactApp}</div>
      </body>
    </html>
    `);
});

app.listen(8080, () => {
  console.log('Server listening on port 8080');
});
```

2. Mover el BrowserRouter del App.js al index.js

```js
// App.js
import React from 'react';
import { Switch, Route, Link } from 'react-router-dom';
import { Home } from './pages/Home';
import { About } from './pages/About';
import { Articles } from './pages/Articles';

const App = () => {
  return (
    <>
      <h1>Server-Side Rendering Example</h1>
      <ul>
        <li>
          <Link to='/'>Home</Link>
        </li>
        <li>
          <Link to='/about'>About</Link>
        </li>
        <li>
          <Link to='/articles'>Articles</Link>
        </li>
      </ul>
      <Switch>
        <Route path='/' exact>
          <Home />
        </Route>
        <Route path='/about'>
          <About />
        </Route>
        <Route path='/articles'>
          <Articles />
        </Route>
      </Switch>
    </>
  );
};

export default App;
```

3. Las responsabilidades del index.js van a cambiar un poco, ya no sera un ReactDOM.render sino un ReactDOM.hydrate, hydrate lo que hace es que toma el HTML pre-renderizado del servidor y le agrega react para que se actualice adecuadamente cuando cambia la data en nuestra aplicacion

```js
// index.js
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { BrowserRouter } from 'react-router-dom';

ReactDOM.hydrate(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>,
  document.getElementById('root')
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
```

1. Por ultimo en nuestro server.js en vez de enviar el HTML basico, vamos a cargar el `index.html` de la carpeta build y reemplazaremos el div con id=root con nuestra reactApp

   - Esto se hace basicamente porque al hacer el build en el index se agregan los scripts al final con un hash random que apunta a los scripts compilados de react, como no podemos saber el nombre final de estos, lo mas facil es manualmente reemplazar el div=root

```js
// server.js
import express from 'express';
import path from 'path';
import fs from 'fs';
import React from 'react';
import { renderToString } from 'react-dom/server';
import { StaticRouter } from 'react-router-dom';
import App from './src/App';

const app = express();

// Por defecto si express esta sirviendo una carpeta estatica y ve que hay un index, y que el usuario esta intentando cargar data de el, inmediatamente envia el index
app.use(express.static('./build', { index: false }));

// Todas las rutas devolvera el HTML
app.get('/*', (req, res) => {
  // render es una funcion a la que le podemos pasar jsx y lo renderizara como html
  const reactApp = renderToString(
    <StaticRouter location={req.url}>
      <App />
    </StaticRouter>
  );

  // Load el index.html
  const templateFile = path.resolve('./build/index.html');
  // Load la data
  fs.readFile(templateFile, 'utf8', (err, data) => {
    if (err) {
      return res.status(500).send(err);
    }

    // Devolvemos el contenido del templateFile con el div reemplazado por nuestra app
    return res.send(
      data.replace('<div id="root"></div>', `<div id="root">${reactApp}</div>`)
    );
  });
});

app.listen(8080, () => {
  console.log('Server listening on port 8080');
});
```
