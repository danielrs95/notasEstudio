# React: Software Architecture

Es el estudio de estructura, organizacion y patrones del desarrollo de un proyecto, primeramente los que impactan la productividad de desarrollo en el tiempo

![1](images/11_1.png)

Software architecture es pensado para ser independiente de la tecnologia que estemos usando, miraremos ejemplos con React

Hay 5 temas principales:

1. Server-side rendering
2. State management: Como manejar apropiadamente la data
3. Data loading: Cual es la relacion apropiada entre front y back y como se comunican mas eficientemente, especialmente en el contexto de server-side rendering
4. Code splitting: Como entregamos eficientemente el codigo al cliente
5. Project organization: Como organizar el codigo de tal manera que sea facil para otros programadores

## Server-Side Rendering

En el flujo normal de una aplicacion de React, el cliente hace una peticion al servidor y carga el `index.html` el cual no contiene nada, ese index le dice al explorador que cargue los scripts de React, que son los que en realidad renderizan todos los elementos HTML en la pagina

Server-Side Rendering es cuando el servidor es el encargado de correr los scripts de React y renderizar los elementos

![2](images/11_2.png)

### Basic React SSR

Teniendo una aplicacion basica de react empezaremos a prepararla para que haga server side rendering

`npm install --save-dev @babel/core @babel/node @babel/preset-env @babel/preset-react nodemon`

`npm install express`

```js
//server.js
import express from 'express';
import React from 'react';
import { renderToString } from 'react-dom/server';

const app = express();

// Todas las rutas devolvera el HTML
app.get('/*', (req, res) => {
  // render es una funcion a la que le podemos pasar jsx y lo renderizara como html
  const reactApp = renderToString(<h1>Hello from the server side</h1>);

  return res.send(`
    <html>
      <body>
        <div id="root">${reactApp}</div>
      </body>
    </html>
    `);
});

app.listen(8080, () => {
  console.log('Server listening on port 8080');
});
```

```json
// .babelrc
{
  "presets": ["@babel/preset-env", "@babel/preset-react"]
}
```

Corremos la aplicacion con `npx babel-node server.js`

### Building and rendering an SSR React App

Por ahora estamos renderizando un HTML basico desde JSX en vez de renderizar nuestra React app, queremos renderizar la app y los componentes de las paginas que tenemos para eso debemos:

1. Build our react app: `npm run build`

   - Esto generara un directorio build que contiene todo el codigo minificado y transpilado

2. Desirle al servidor que sirva estaticamente los archivos dentro de la carpeta build y renderizar el componente Home. Para correr `npx nodemon --exec npx babel-node server.js`

```js
// server.js
import express from 'express';
import React from 'react';
import { renderToString } from 'react-dom/server';
import { Home } from './src/pages/Home';

const app = express();

// Por defecto si express esta sirviendo una carpeta estatica y ve que hay un index, y que el usuario esta intentando cargar data de el, inmediatamente envia el index
app.use(express.static('./build', { index: false }));

// Todas las rutas devolvera el HTML
app.get('/*', (req, res) => {
  // render es una funcion a la que le podemos pasar jsx y lo renderizara como html
  const reactApp = renderToString(<Home />);

  return res.send(`
          <html>
            <body>
              <div id="root">${reactApp}</div>
            </body>
          </html>
          `);
});

app.listen(8080, () => {
  console.log('Server listening on port 8080');
});
```

### Routing with server side rendering

Acabamos de renderizar 1 solo componente, pero lo ideal seria renderizar toda la APP, es decir, el app.js y esto no lo habiamos hecho porque tenemos que realizar el routing

1. Importaremos StaticRouter, basicamente es el equivalente a BrowserRouter que usamos en el frontend

   - Se le pasa un prop llamado location, que le permite saber que ruta esta solicitando el usuario

```js
// server.js
import express from 'express';
import React from 'react';
import { renderToString } from 'react-dom/server';
import { StaticRouter } from 'react-router-dom';
import App from './src/App';

const app = express();

// Por defecto si express esta sirviendo una carpeta estatica y ve que hay un index, y que el usuario esta intentando cargar data de el, inmediatamente envia el index
app.use(express.static('./build', { index: false }));

// Todas las rutas devolvera el HTML
app.get('/*', (req, res) => {
  // render es una funcion a la que le podemos pasar jsx y lo renderizara como html
  const reactApp = renderToString(
    <StaticRouter location={req.url}>
      <App />
    </StaticRouter>
  );

  return res.send(`
    <html>
      <body>
        <div id="root">${reactApp}</div>
      </body>
    </html>
    `);
});

app.listen(8080, () => {
  console.log('Server listening on port 8080');
});
```

2. Mover el BrowserRouter del App.js al index.js

```js
// App.js
import React from 'react';
import { Switch, Route, Link } from 'react-router-dom';
import { Home } from './pages/Home';
import { About } from './pages/About';
import { Articles } from './pages/Articles';

const App = () => {
  return (
    <>
      <h1>Server-Side Rendering Example</h1>
      <ul>
        <li>
          <Link to='/'>Home</Link>
        </li>
        <li>
          <Link to='/about'>About</Link>
        </li>
        <li>
          <Link to='/articles'>Articles</Link>
        </li>
      </ul>
      <Switch>
        <Route path='/' exact>
          <Home />
        </Route>
        <Route path='/about'>
          <About />
        </Route>
        <Route path='/articles'>
          <Articles />
        </Route>
      </Switch>
    </>
  );
};

export default App;
```

3. Las responsabilidades del index.js van a cambiar un poco, ya no sera un ReactDOM.render sino un ReactDOM.hydrate, hydrate lo que hace es que toma el HTML pre-renderizado del servidor y le agrega react para que se actualice adecuadamente cuando cambia la data en nuestra aplicacion

```js
// index.js
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { BrowserRouter } from 'react-router-dom';

ReactDOM.hydrate(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>,
  document.getElementById('root')
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
```

1. Por ultimo en nuestro server.js en vez de enviar el HTML basico, vamos a cargar el `index.html` de la carpeta build y reemplazaremos el div con id=root con nuestra reactApp

   - Esto se hace basicamente porque al hacer el build en el index se agregan los scripts al final con un hash random que apunta a los scripts compilados de react, como no podemos saber el nombre final de estos, lo mas facil es manualmente reemplazar el div=root

```js
// server.js
import express from 'express';
import path from 'path';
import fs from 'fs';
import React from 'react';
import { renderToString } from 'react-dom/server';
import { StaticRouter } from 'react-router-dom';
import App from './src/App';

const app = express();

// Por defecto si express esta sirviendo una carpeta estatica y ve que hay un index, y que el usuario esta intentando cargar data de el, inmediatamente envia el index
app.use(express.static('./build', { index: false }));

// Todas las rutas devolvera el HTML
app.get('/*', (req, res) => {
  // render es una funcion a la que le podemos pasar jsx y lo renderizara como html
  const reactApp = renderToString(
    <StaticRouter location={req.url}>
      <App />
    </StaticRouter>
  );

  // Load el index.html
  const templateFile = path.resolve('./build/index.html');
  // Load la data
  fs.readFile(templateFile, 'utf8', (err, data) => {
    if (err) {
      return res.status(500).send(err);
    }

    // Devolvemos el contenido del templateFile con el div reemplazado por nuestra app
    return res.send(
      data.replace('<div id="root"></div>', `<div id="root">${reactApp}</div>`)
    );
  });
});

app.listen(8080, () => {
  console.log('Server listening on port 8080');
});
```

### Styling with server side rendering

La manera como usualmente usamos estilos en una aplicacion de react es usando CSS modules, para que estos funcionen en el servidor deberiamos configurar el webpack lo cual es engorroso como vimos en el curso pasado

Otra alternativa a esto es usar `styled components`, tal como lo vimos previamente

- `npm i styled-components`

Basicamente, cuando style components se corre en el cliente este agrega una clase especial a cada uno de los componentes y luego genera el CSS

Cuando estamos haciendo server side rendering, hay que eliminar todos los estilos de la app e insertarlos en el index.html tal como insertamos la app en el div con id=root

1. Importamos ServerStyleSheet y con este, creamos una nueva variable que se encargara de eliminar todos los estilos de nuestra app

```js
// server.js

import { ServerStyleSheet } from 'styled-components';
  const reactApp = renderToString(
     const sheet = new ServerStyleSheet();

    sheet.collectStyles(
      <StaticRouter location={req.url}>
        <App />
      </StaticRouter>
    )
  );
```

2. Reemplazamos en nuestro index.html (el index del build) pero no tenemos un tag que reemplazar, para esto en el index.html escribimos `{{styles}}` y asi al hacer el replace, iremos a buscar este texto en el index

```js
// server.js

fs.readFile(templateFile, 'utf8', (err, data) => {
  if (err) {
    return res.status(500).send(err);
  }

  // Devolvemos el contenido del templateFile con el div reemplazado por nuestra app y tambien agregamos los estilos
  return res.send(
    data
      .replace('<div id="root"></div>', `<div id="root">${reactApp}</div>`)
      .replace('{{styles}}', sheet.getStyleTags())
  );
});
```

```js
import express from 'express';
import path from 'path';
import fs from 'fs';
import React from 'react';
import { ServerStyleSheet } from 'styled-components';
import { renderToString } from 'react-dom/server';
import { StaticRouter } from 'react-router-dom';
import App from './src/App';

const app = express();

// Por defecto si express esta sirviendo una carpeta estatica y ve que hay un index, y que el usuario esta intentando cargar data de el, inmediatamente envia el index
app.use(express.static('./build', { index: false }));

// Todas las rutas devolvera el HTML
app.get('/*', (req, res) => {
  const sheet = new ServerStyleSheet();

  const reactApp = renderToString(
    sheet.collectStyles(
      <StaticRouter location={req.url}>
        <App />
      </StaticRouter>
    )
  );

  // Load el index.html
  const templateFile = path.resolve('./build/index.html');
  // Load la data
  fs.readFile(templateFile, 'utf8', (err, data) => {
    if (err) {
      return res.status(500).send(err);
    }

    // Devolvemos el contenido del templateFile con el div reemplazado por nuestra app
    return res.send(
      data
        .replace('<div id="root"></div>', `<div id="root">${reactApp}</div>`)
        .replace('{{styles}}', sheet.getStyleTags())
    );
  });
});

app.listen(8080, () => {
  console.log('Server listening on port 8080');
});
```

## State Management

El state management es como una aplicacion maneja la data que necesitan los componentes y ademas como como dichos componentes cargan, almacenan, guardan y comparten dicha data

### State management technologies

1. useState Hook
2. Context
3. Recoil
4. Redux
5. Mobx

### Different sizes of states

La tecnologia que usemos para manejar el estado depende de:

1. El size y complejidad de nuestra app(blog vs ecommerce)
2. Cuantos componentes van a compartir la data de la app
3. Ver las fortalezas y debilidades de cada una de las tecnologias

- Small state: useState, Context
- Medium state: Recoil
- Large state: Redux, Mobx

### Recoil

`npm 1 recoil`

Funciona parecido al provider, en vez de envolver toda la app en un Provider, lo envolvemos en un `RecoilRoot`, este se encarga de vigilar el estado de toda la app y permitir a los componentes que se encuentren adentro de el acceder al estado, basicamente es un `store` de Redux

```js
// 03_05b
// App.js
import { RecoilRoot } from 'recoil';
import { CounterButton } from './CounterButton';
import './App.css';

const App = () => {
  return (
    <RecoilRoot>
      <h1>State Management Example</h1>
      <CounterButton />
    </RecoilRoot>
  );
};

export default App;
```

Recoil tiene 2 conceptos principales, atoms & selectors

1. Atoms: valores individuales que queremos almacenar en el Recoil State

   - Hace uso de una funcion `atom` de recoil que permite crear nuevas secciones del estado, se le debe pasar un objeto para configurarlo con un key y un valor

```js
// counterState.js
import { atom } from 'recoil';

export const counterState = atom({
  key: 'counterState',
  default: 0,
});

// incrementByState.js
import { atom } from 'recoil';

export const incrementByState = atom({
  key: 'incrementByState',
  default: 1,
});
```

2. Luego pasamos un hook que tiene recoil el cual permite acceder al estado definiendolo como hacemos con el `useState`

```js
import { useRecoilState } from 'recoil';
import { counterState } from './counterState';
import { incrementByState } from './incrementByState';

export const CounterButton = () => {
  const [numberOfClicks, setNumberOfClicks] = useRecoilState(counterState);
  const [incrementBy, setIncrementBy] = useRecoilState(incrementByState);

  return (
    <>
      <p>You have clicked the button {numberOfClicks} times.</p>
      <label>
        Increment By:
        <input
          value={incrementBy}
          onChange={(e) => setIncrementBy(Number(e.target.value))}
          type='number'
        />
      </label>
      <button onClick={() => setNumberOfClicks(numberOfClicks + incrementBy)}>
        Click
      </button>
    </>
  );
};
```

### Selectors

Los selectors al igual que como vimos en el curso de Building Modern Projects with react, se usan para calcular o manipular data del estado

```js
import { selector } from 'recoil';
import { counterState } from './counterState';

export const numberOfClicksSelector = selector({
  key: 'numberOfClicksSelector',
  get: ({ get }) => {
    const clicksData = get(counterState);
    const totalClicks = clicksData.reduce((sum, click) => {
      return sum + click.amount;
    }, 0);
    console.log(totalClicks);
    return totalClicks;
  },
});
```

### Mobx

Es otra manera de manejar estado en aplicaciones muy grandes pero es mas orientada a objetos hay que definir una clase, con nsu cosntructor y metodos que se encargaran de manejar el estado

## Data loading & WebSockets

Al estar usando server side y querer cargar datos a la aplicacion hay varias maneras en las que se pueden hacer las peticiones

1. Hacer el fetch desde el componente en el frontend, sin embargo, esto tiene una limitacion y es que estamos cargando el index y despues estamos anexando la peticion que hacemos con el fetch

Basicamente, estamos haciendo server side al index pero la data que hay que cargar no esta siendo renderizada en el servidor, lo ideal, es que el frontend no haga las peticiones al servidor

```js
import express from 'express';
import React from 'react';
import { ServerStyleSheet } from 'styled-components';
import { renderToString } from 'react-dom/server';
import { StaticRouter } from 'react-router-dom';
import path from 'path';
import fs from 'fs';
import App from './src/App';

const app = express();

app.use(express.static('./build', { index: false }));

const articles = [
  { title: 'Article 1', author: 'Bob' },
  { title: 'Article 2', author: 'Betty' },
  { title: 'Article 3', author: 'Frank' },
];

app.get('/api/articles', (req, res) => {
  // Esta seria la peticion a la base de datos
  const loadedArticles = articles;
  res.json(loadedArticles);
});

app.get('/*', (req, res) => {
  const sheet = new ServerStyleSheet();

  const reactApp = renderToString(
    sheet.collectStyles(
      <StaticRouter location={req.url}>
        <App />
      </StaticRouter>
    )
  );

  const templateFile = path.resolve('./build/index.html');
  fs.readFile(templateFile, 'utf8', (err, data) => {
    if (err) {
      return res.status(500).send(err);
    }

    return res.send(
      data
        .replace('<div id="root"></div>', `<div id="root">${reactApp}</div>`)
        .replace('{{ styles }}', sheet.getStyleTags())
    );
  });
});

app.listen(8080, () => {
  console.log('Server is listening on port 8080');
});
```

```js
// Articles.js
import React, { useState, useEffect } from 'react';

export const Articles = () => {
  const [articles, setArticles] = useState();

  useEffect(() => {
    fetch('/api/articles')
      .then((response) => response.json())
      .then((data) => setArticles(data));
  }, []);

  return (
    <>
      <h1>Articles</h1>
      {articles &&
        articles.map((article) => (
          <div key={article.title}>
            <h3>{article.title}</h3>
            <p>by {article.author}</p>
          </div>
        ))}
    </>
  );
};
```

### Data loading with SSR

1. Debemos cargar la data en donde hacemos la renderizacion del html
2. Una manera de hacer esto es entregar la data al documento HTML, basicamente con un script que tendra el JSON con la data

Sin embargo, el servidor sigue sin renderizar estos articulos, no es hasta que la app llega al buscador del usuario que estos cambios son re-renderizados por el frontend con react cuando hace el llamado al hydrate

```js
import express from 'express';
import React from 'react';
import { ServerStyleSheet } from 'styled-components';
import { renderToString } from 'react-dom/server';
import { StaticRouter } from 'react-router-dom';
import path from 'path';
import fs from 'fs';
import App from './src/App';

// Definimos una variable global para que no falle el cliente al intentar acceder a ella
global.window = {};

const app = express();

app.use(express.static('./build', { index: false }));

const articles = [
  { title: 'Article 1', author: 'Bob' },
  { title: 'Article 2', author: 'Betty' },
  { title: 'Article 3', author: 'Frank' },
];

app.get('/api/articles', (req, res) => {
  const loadedArticles = articles;
  res.json(loadedArticles);
});

app.get('/*', (req, res) => {
  const sheet = new ServerStyleSheet();

  const reactApp = renderToString(
    sheet.collectStyles(
      <StaticRouter location={req.url}>
        <App />
      </StaticRouter>
    )
  );

  const templateFile = path.resolve('./build/index.html');
  fs.readFile(templateFile, 'utf8', (err, data) => {
    if (err) {
      return res.status(500).send(err);
    }

    // Data cargada de la base de datos
    const loadedArticles = articles;

    return res.send(
      data
        .replace(
          '<div id="root"></div>',
          // Al objeto window le agregamos la propiedad preloadedArticles
          `<script>window.preloadedArticles = ${JSON.stringify(
            loadedArticles
          )};</script><div id="root">${reactApp}</div>`
        )
        .replace('{{ styles }}', sheet.getStyleTags())
    );
  });
});

app.listen(8080, () => {
  console.log('Server is listening on port 8080');
});
```

```js
// Articles.js
import React, { useState, useEffect } from 'react';

export const Articles = () => {
  // Cargamos los articulos del objeto window
  const [articles, setArticles] = useState(window && window.preloadedArticles);

  useEffect(() => {
    if (window && !window.preloadedArticles) {
      console.log('No preloaded articles found, loading from server');
      fetch('/api/articles')
        .then((response) => response.json())
        .then((data) => setArticles(data));
    }
  }, []);

  return (
    <>
      <h1>Articles</h1>
      {articles &&
        articles.map((article) => (
          <div key={article.title}>
            <h3>{article.title}</h3>
            <p>by {article.author}</p>
          </div>
        ))}
    </>
  );
};
```

###
